


globalVariables(c(
  "drg", "n_", "out"
))


#' ROR, PRR, BCPNN (MCMC and norm) of a \code{nx2} contingency table
#'
#' @author Ty Stanford <tystan@gmail.com>
#' @description ROR, PRR, BCPNN (MCMC and norm) of a \code{nx2} contingency table
#' @param nx2_tab A tabulation of counts with \code{n} >= rows and \code{2} columns. The first column is the event of interest, the second
#' being other events. The rows are \code{n} drugs/exposures.
#' @param orig_scale \code{FALSE} (default), do you want the estimates to be on the ratio scale (e.g., BCPNN is on the log2 scale)
#' @param alpha for construction of the \code{100*(1-alpha)\%} confidence intervals
#' @param n_mcmc number of MCMC simulations per \code{(a,b,c,d)}-tuple
#' @param min_events the minimum number of events of interest for each drug/exposure to generate signal calculations. Default is 3.
#' @export
#' @details
#' In addition to \code{nx2_tab} representing counts with n >= rows and 2 columns, the \code{class} of \code{nx2_tab}
#' must be \code{"table"}. This is achieved by using \code{table()} on columns of record level data or converting a 
#' \code{matrix}/\code{data.frame} of counts using \code{as.table()}.
#'
#' @return 
#' The function returns a \code{data.frame} that is returned for \code{battery_signal()} for each of 
#' the \code{n} drugs/exposures.
#' 
#' @examples 
#' set.seed(1234)
#' library(dplyr)
#' # some made up record level data
#' drg <- base::sample(paste0("drg_", LETTERS[1:5]), size = 1000, replace = TRUE)
#' outc <- base::sample(paste0("outc_", LETTERS[25:26]), size = 1000, replace = TRUE)
#' (drg_tab <- table(drg, outc))
#' nx2_to_signal(drg_tab, orig_scale = TRUE)

nx2_to_signal <- function(nx2_tab, orig_scale = FALSE, alpha = 0.05, n_mcmc = 1e5, min_events = 3) {
  
  # make sure we have not NULL or NA vals, valid positive integer values etc
  check_all_positive_ints(as.vector(nx2_tab), warn_zeros = FALSE)
  
  if (any(class(nx2_tab) != "table")) {
    stop("Please make sure the input nx2_tab is of class 'table' generated by the function table()")
  }
  
  if (length(dim(nx2_tab)) != 2) {
    stop("Please make sure the input nx2_tab is 2-dim cross tabulation")
  }
  
  if (dim(nx2_tab)[1] < 2) {
    stop("There must be at least 2 rows in the input nx2_tab")
  }
  
  if (dim(nx2_tab)[2] != 2) {
    stop("There must be exactly 2 columns in the input nx2_tab")
  }

  # easiest way to deal with table values is to convert to a long format of the counts
  # and the margin levels are the variables
  tab <- as.data.frame(nx2_tab, stringsAsFactors = FALSE)
  colnames(tab) <- c("drg", "out", "n")
  nr <- nrow(nx2_tab)
  rnms <- rownames(nx2_tab)
  cnms <- colnames(nx2_tab)
  outc_int <- cnms[1] # outcome of interest
  outc_not <- cnms[2] # complement of outcome of interest 
  
  i <- NULL # initialise so no error in building package (and don't want to globalise this variable!)
  onevall <-
    foreach(i = 1:nr, .combine = bind_rows) %do% {
      
      drg_i <- rnms[i] 
      not_drg_i <- paste0("* (excl ", drg_i, ")") # label for not drg_i
      
      tmp_df <- 
        tab %>%
        dplyr::mutate(drg = if_else(drg == drg_i, drg, not_drg_i)) %>%
        group_by(drg, out) %>% 
        summarise(n_ = sum(n), .groups = "keep")
      
      # exposure and outc of interest
      a <- 
        tmp_df %>% 
        dplyr::filter(drg == drg_i, out == outc_int) %>% 
        pull(n_)
      
      if (a >= min_events) {
        
        names(a) <-
          paste(
            drg_i, "/", not_drg_i, 
            " vs ", 
            outc_int, "/", outc_not,
            sep = ""
          )
        
        b <- 
          tmp_df %>% 
          dplyr::filter(drg == drg_i, out == outc_not) %>% 
          pull(n_)
        c <- 
          tmp_df %>% 
          dplyr::filter(drg == not_drg_i, out == outc_int) %>% 
          pull(n_)
        d <- 
          tmp_df %>% 
          dplyr::filter(drg == not_drg_i, out == outc_not) %>% 
          pull(n_)
        
        drg_i_signal <-
          battery_signal(
            a, b, c, d,
            orig_scale = orig_scale, alpha = alpha, n_mcmc = n_mcmc
          )
        
        drg_i_signal$analysis <- drg_i
          
        drg_i_signal
        
      } else {
        
        cat("NOTE:", drg_i, "did not have", min_events, "or more events of interest to produce output.\n")
        NULL # no data.frame entries for those drugs not meeting min_events
        
      }
      
    }
  
  return(onevall)
  
}

